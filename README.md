<!--  

заметки


Темы которые надо изучить
- commit
- branch
- checkout
- cherry-pick
- reset
- revert
- rebase
- merge
- squash
- bisect
- fetch
- clone


-->

# Введение

Гид представляет данные как снимок состояния миниатюрной файловой и ссылки на эти снимки системы а не как список изменений.

Самое тяжелое с чем придется свыкнутся, это то что практически любое действие будет приводить к появлюнию данных в истории вашей программы, на локалке еще как-то можно удалять коммиты, но в репозитории это как правило не приводит к хорошим результатам. это просто то как он работает.

## Состояния файлов

Файлы в гите могут находится в 3 состояниях

- зафиксированное(commited) - данные сохранены локально.
- модифицированное(modified) - изменения внесены в файл.
- индексированное(staged) - означает, что вы пометили текущую версию модифицированного файла как преднозначенную для следующей фиксации.

Это происходит так:
1. Из локального репозитория запись в область индексирования
2. Из области индексации фиксация в удаленный репозиторий
3. Их удаленного репозитория контрольное считывание проекта в локальный репозиторий

<br>

# Работа с зоной индекстирования

git add file_name - добавляет файл в зону индексирования

git reset HEAD file_name - удаляет файл из зоны индексирования

<br>

# Работа с логированием и историей

git log --stat - выводит краткую информащию по каждому коммиту

git log --pretty - выводит историю красиво
> --pretty=format: ... позволяет очень точно настроит выводимую историю, по умолчанию выводит --oneline

git log --graph - выводит историю в виде древовидного графика

git log --Sstring_name - эта комманда выводит историю тех коммитов в которых добавлялась или удалялась данная строка

git rm - удаляет файл из числа отслеживаемых файлов
> только так необходимо удалять файлы в локальном репозитории

git rm -f - удаляет фай который уже находится в зоне индексирования

git mv - перемещение файлов
> git не отслеживает перемещение файлов, эта команда позволяет отслеживать перемещение файлов в истории 

git diff - показывает изменения между коммитами

git diff --staged - сравнивает индексируемые изменения с последним коммитом

git diff --cached - покажет проиндексированные изменения

git commit -m "message_body" - выполнить коммит с комментарием

git remote show origin - отображает информацию об удаленном репозитории,
в частности ветки, их состояние и url репозитория

<br>

# Работа с репозиторием <!-- Как работать с ветками и коммитами -->

## Подготовка и настройка

git remote add origin origin_url - переносит всю историю коммитов в репозиторий

git branch -M branch_name - меняет имя основной ветки на указанное

git fetch branch_name - копирует все коммиты указанной ветки которые отсутсвуют в локальном репозитории
> В отличии от git pull не удаляет отсутсвующие в удаленном репозитории изменения

git pull - обновляет локальный репозиторий до состояния удаленного
> ВАЖНО! удаляет все что не находится в последнем снимке состояния удаленного репозитория

git config --list - отображает список конфигураций git

git config --global alias.alias_name alias_body - создает сокращения для git комманд

git config --global alias.alias_name "!alias_body" - создает сокращения для комманд которые не являются git коммандами  

## Работа с ветками

git checkout branch_or_commit_name - используется для переключения между ветками и коммитами
> ВАЖНО! git checkout переключение между ветками и коммитами изменяет файлы в рабочем каталоге

git checkout -b branch_name - создает новую ветку и переводит на ней указатель.

git branch - создает новую ветку.

git branch -m branch_name - изменит имя старой ветки на новую

git rebase branch_name - переносит коммит на котором находится указатель 

git merge commit_name - сводит вместе коммит из другой ветки в коммит ветки где находится указатель

git branch -u barnch_name - ветка на которой находится HEAD начинает отслеживать указанную удаленную ветку

## Работа с коммитами

git commit --amend -m "new_message" - изменить сообщение коммита

git push -u origin branch_name - пушит изменения в указанную ветку
> -u делает так что при git pull смотрит последний коммит в указанной ветки и обновляется с него

git push origin branch_name --force - перепишет коммит в репозитории
> Если у вас нет тех коммитов которые есть в репозитории, после выполнениия вы потеряете их навсегда 

git cherry-pick commin_1 commit_2 ... commit_n - копирует комиты из другой ветки в указатель
> нельзя копировать коммиты котыре существовали до коммита на котором стоит указатель, в том числе предыдущие коммиты из родительской ветки. 

<br>

# Продвинутые техники

## Игнорирование

Для игнорирования используется файл .gitignore